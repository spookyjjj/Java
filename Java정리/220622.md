- Set(집합) : 중복배제, ★인덱스없음
  - [HashSet](../workspace/220622-01_set/src/Main.java)
    - `.add(원소)`의 리턴이 boolean. 참이면 중복아님->담는다 / 거짓이면 중복->안담는다
	- [모두출력](../workspace/220622-01_set/src/Main.java) : 인덱스가 없으니 for문(X), toString(O), for-each문(O) iterator(O) -> 단, 순서가 없기 때문에 지 맘대로 나옴
	- [응용](../workspace/220622-01_set/src/Main3.java) : list에 중복값이 있다면 빼고싶다? -> set갔다가 돌아오면 됨
	- [응용2](../workspace/220622-01_set/src/Main4.java) : 교집합?, 차집합?, 동등한집합?
	- [예제](../workspace/220622-01_set/src/T0622.java) : 로또번호출력기
  - [LinkedHashSet](../workspace/220622-01_set/src/Main5.java)
    - 인덱스 없는건 마찬가지!! just 앞에 들어온놈 뒤에들어온놈만 구분함 -> 오래된것부터 순서대로 나옴
  - [TreeSet](../workspace/220622-01_set/src/Main6.java)
    - 인덱스 없는건 마찬가지!! just 대소비교만 해서 앞에둘놈 뒤에둘놈만 구분함 -> 작은것부터 순서대로 나옴
  - [Set에서의 동일?](../workspace/220622-01_set/src/Main7.java)
    - equals를 바로 찾아가지 않는다 -> ★1차적으로 hashcode보고 동일이 나오면 2차적으로 equals체크!
	- 즉 hashcode가 다르면 다른 객체, hashcode와 equals까지 같아야 같은 객체
	- hashcode는 객체 생성될 때 마다 다르게 주어지는게 디폴트임으로, equals()처럼 hashcode()도 오버라이드 필요
- Map : key를 통해 value를 가져온다, ★인덱스없음, key는 중복이 없어야 하므로 Set!
  - [HashMap](../workspace/220622-02_map/src/Main.java)
    - `.put(key값, value값)`, `.containsKey(key값)`  
    - `.keySet()` -> key들을 Set로 반환  
	- `.entrySet()` -> key와 value를 Entry(Pair)라는 타입으로 반환 -> `.getKey()`, `.getValue()`
	- [모두출력](../workspace/220622-02_map/src/Main2.java) : 인덱스대신 key가 있다!
	  - keySet을 이용하여 for-each문
	  - keySet을 이용하여 iterator
	  - entry를 이용하여 for-each문
	- [교제예제](../workspace/220622-02_map/src/MapTest.java) : key값 value값을 내가 생성한 클래스로 두기
	- [교제예제2](../workspace/220622-02_map/src/WordFreq.java) : list에 담긴 원소들의 빈도값 구하는 예제  
  - [LinkedHashMap](../workspace/220622-02_map/src/Main3.java)
  - [TreeMap](../workspace/220622-02_map/src/Main3.java) : key기준!!!
---- 
> 마무리문제  
> : [모스부호반환프로그램](../workspace/220622-02_map/src/Morse.java)  
> : [중국집 주문 가격 계산기](../workspace/220622-02_map/src/T0622_2.java)  
